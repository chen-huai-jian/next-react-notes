# next 定义路由 有两种方式

最新的是 app Router next 的版本 >13.4 直接在 app 下面定义路由文件 app/page.js

旧的是 pages Router 有个 pages 文件夹。

两者可以共存，App Router 的优先级要高于 Pages Router。 注意：两者为同一个 Router，会报错。。

新版路由 page.js 代表 传统的 index.js 为默认访问页面。。。

layout.js 的文件，会包裹同层级的 page

template.js 模板文件, 与 layout 类似，也会包裹同层级的 page. 区别在于 状态保持，layout 会保持状态。

loading.js 页面 ，与 react de suspence 类似，在加载组件过程中 展示 loading 效果。。

not-found.js 404 页面

层级关系为：

![img](![Alt text](image.png))

# 跳转路由

<Link> 组件

useRouter Hook 方法

# 动态路由

文件夹命名为 [folderName] ，则为 动态路由，在文件夹下的 page.js 组件参数 就能拿到 param.

当设置为 [...folderName]时，则 获取所有的子孙路由（不包括当前的根路由）。

还能设置为 [[...folderName]], 可选的捕获所有后面所有的路由片段。 和上面的区别为 可以匹配当前的 根路由。

路由组 (folderName) 可以创建不同的布局 创建多个根布局

平行路由 文件名称加个 @folderName , , 可以条件渲染 展示不同页面 可以 把错误渲染 独立出来

拦截路由 (..)folderName

# route.js 定义路由处理程序

每个方法参数都有两个参数 request context

request: 可以获取 参数 和 cookie 等

context: 只有一个值就是 params，它是一个包含当前动态路由参数的对象。

使用 Response 对象返回的 get 方法 会被缓存。。

# 服务端组件

- next 默认使用 服务端组件

- 静态渲染
  数据必须被缓存。

- 动态渲染
  使用动态函数或退出缓存的数据请求的数据请求。

  - 动态函数是指 只能在请求时才能得到的信息。

```js
  cookies和headers.
  useSearchParams().
  searchParams.
```

    - 退出缓存的请求。

# 客户端组件

在顶部声明 'use client'

# 缓存相关

默认会开启缓存。。。

# 样式相关

内联 css

css module， 文件后缀 .module.css； 默认就会变成 模块化 css，然后 import 引入。。。

全局样式  
引入全局样式表

外部样式
引入外部样式表

Tailwind Css(官方推荐)

```JS
npm install - D tailwindcss postcss autoprefixer
npx tailwindcss init - p

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',

    // 嫌麻烦，你也可以直接使用 `src` 目录
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

css in js

```JS
// styled-components 举例
1. 创建一个全局样式 注册表
  'use client'
// lib/registry.js
import React, {
  useState
} from 'react'
import {
  useServerInsertedHTML
} from 'next/navigation'
import {
  ServerStyleSheet,
  StyleSheetManager
} from 'styled-components'

export default function StyledComponentsRegistry({
  children
}) {
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement()
    styledComponentsStyleSheet.instance.clearTag()
    return < > {
      styles
    } < />
  })

  if (typeof window !== 'undefined') return < > {
    children
  } < />

  return ( <
    StyleSheetManager sheet = {
      styledComponentsStyleSheet.instance
    } > {
      children
    } <
    /StyleSheetManager>
  )
}
2. 使用 useServerInsertedHTML hook 在内容被使用前注入样式规则
// app/layout.js
import StyledComponentsRegistry from './lib/registry'

export default function RootLayout({
  children
}) {
  return ( <
    html >
    <
    body >
    <
    StyledComponentsRegistry > {
      children
    } < /StyledComponentsRegistry> < /
    body > <
    /html>
  )
}
3. 使用包含样式i注册表的客户端组件包裹应用
```

sass

```JS
// next.config.js
const path = require('path')

module.exports = {
  sassOptions: {
    includePaths: [path.join(__dirname, 'styles')],
  },
}
```

# 内置 Link 组件

用于 预加载和客户端路由之间的导航

| Prop     | 实例              | 类型             | 是否必须 | 解释                       |
| -------- | ----------------- | ---------------- | -------- | -------------------------- |
| href     | href="/dashboard" | String or Object | 是       | 跳转路径 可带参数传递      |
| replace  | replace={false}   | Boolean false    | 否       | 会替换浏览器当前的历史记录 |
| scroll   | scroll={false}    | Boolean true     |          | 是否滚动到顶部             |
| prefetch | prefetch={false}  | Boolean true     |          |

- href 必须

```JS
//JavaScript
<
Link href = "/dashboard" > Dashboard < /Link>

  // 导航至 /about?name=test
  <
  Link href = {
    {
      pathname: '/about',
      query: {
        name: 'test'
      },
    }
  } >
  About <
  /Link>
/// 所有参数
href： '<http://user:pass@host.com:8080/p/a/t/h?query=string#hash>'
protocol： 'http:'
host: 'host.com:8080'
auth: 'user:pass'
hostname: 'host.com'
port: '8080'
pathname: '/p/a/t/h'
search: '?query=string'
path: '/p/a/t/h?query=string'
query: 'query=string'
or {
  'query': 'string'
}
hash: '#hash'
```

# 内置 Script

用于加载和执行三方脚本文件

| prop     | 示例                  | 类型     | 是否必须 | 描述                                      |
| -------- | --------------------- | -------- | -------- | ----------------------------------------- |
| src      | scr=""                | String   | 必须     |
| strategy | strategy="lazyOnload" | String   |          |
| onLoad   | onLoad={onLoadFunc}   | Function |          | 不能在服务端使用，只能在客户端 ，首次加载 |
| onReady  | onReady={onReadyFunc} | Function |          | 每次加载，只能在客户端                    |
| onError  | onError={onErrorFunc} | Function |          | 加载失败捕获错误                          |

- strategy 四种 策略

  beforeInteractive：在可交互前加载，适用于 cookie 管理等、 必须放在 根布局中
  afterInteractive: 默认值，在可交互后加载，适用于数据统计。
  lazyOnload： 在浏览器空闲时间加载
  worker: （实验性质）通过 web worker 加载




# 部署

next build 导出的时候，生成静态文件 out



# API 篇

## headers

```JS
module.exports = {
  async headers() {
    return [
      {
        source: '/about',
        headers: [
          {
            key: 'x-custom-header',
            value: 'my custom header value',
          },
          {
            key: 'x-another-custom-header',
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

headers 是一个异步函数，该函数返回一个包含 source 和 headers 属性的对象数组
    source: 表示传入的请求路径
    header: 是一个包含key和value属性的响应标头对象数组。

    basePath: false 或者 undefined. 值为false，匹配时不会包含 basePath,只能用于外部重写。
    locale: false 或者 undefined,匹配时是否应该包含locale.
    has: 一个有 type, key, value, 属性的对象数组。
    missing：一个有type，key，value 的对象数组。


## redirects 

```JS
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
    ]
  },
}
```

  source: 表示传入的请求路径
  destination: 表示重定向的目标路径
  permanent: 值为true/false。 true：308，表示客户端或搜索引擎永久缓存重定向；false: 307, 使用307 表示临时未缓存。

  basePath：false 或者 undefined。当值为 false ，匹配时不会包含 basePath，只能用于外部重写
  locale：false 或者 undefined，匹配时是否应该包含 locale
  has：一个有 type、key、value 属性的对象数组
  missing：一个有 type、key、value 属性的对象数组



## rewrites 

```JS
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  },
}
```

其余参数一样